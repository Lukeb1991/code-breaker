<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CODE BREAKER // OPS TERMINAL</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<style>
  :root{
    --bg:#040806;
    --panel:#07130e;
    --panel2:#06110c;
    --grid:#0a1c14;

    --green:#35ff9b;
    --green2:#1ea86a;
    --amber:#ffcc66;
    --red:#ff5f5f;
    --cyan:#62e6ff;

    --border: rgba(53,255,155,.28);
    --border2: rgba(53,255,155,.18);
    --shadow: 0 18px 60px rgba(0,0,0,.55);
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    color:var(--green);
    background:
      radial-gradient(900px 700px at 30% 10%, rgba(53,255,155,.10) 0%, transparent 60%),
      radial-gradient(900px 700px at 80% 90%, rgba(98,230,255,.08) 0%, transparent 55%),
      linear-gradient(180deg, #020504, var(--bg));
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    overflow-x:hidden;
  }

  /* CRT scanlines + vignette */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    background:
      repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.025),
        rgba(255,255,255,0.025) 1px,
        transparent 1px,
        transparent 3px
      );
    mix-blend-mode:overlay;
    opacity:.55;
  }
  body::after{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    background: radial-gradient(closest-side at 50% 50%, transparent 55%, rgba(0,0,0,.55) 100%);
    opacity:.65;
  }

  .wrap{
    min-height:100%;
    display:flex;
    justify-content:center;
    padding:
      max(14px, env(safe-area-inset-top))
      14px
      max(18px, env(safe-area-inset-bottom));
  }

  .app{
    width:min(740px, 100%);
    display:grid;
    gap:12px;
    align-content:start;
  }

  .topbar{
    background: linear-gradient(180deg, rgba(7,19,14,.92), rgba(6,17,12,.86));
    border:1px solid var(--border);
    box-shadow: var(--shadow);
    border-radius:16px;
    padding:12px 12px 10px;
    display:grid;
    gap:10px;
  }

  .toprow{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:10px;
  }

  .brand{
    display:grid;
    gap:4px;
  }
  .brand .title{
    font-weight:800;
    letter-spacing:2px;
    font-size:16px;
    line-height:1.1;
  }
  .brand .sub{
    color:rgba(53,255,155,.70);
    font-size:12px;
    line-height:1.25;
  }

  .controls{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .btn{
    border:1px solid var(--border2);
    background: rgba(6,17,12,.55);
    color:var(--green);
    padding:10px 10px;
    border-radius:12px;
    font-weight:800;
    letter-spacing:1px;
    cursor:pointer;
    user-select:none;
    font-size:12px;
    min-height:42px;
  }
  .btn:hover{ border-color: var(--border); }
  .btn:active{ transform: translateY(1px); }
  .btn.alt{ color: var(--cyan); border-color: rgba(98,230,255,.20); }
  .btn.danger{ color: var(--red); border-color: rgba(255,95,95,.25); }

  .meta{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .pill{
    border:1px solid var(--border2);
    background: rgba(6,17,12,.45);
    border-radius:14px;
    padding:10px 10px;
    min-height:46px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:12px;
  }
  .pill b{ letter-spacing:1px; }
  .pill .value{ color:rgba(53,255,155,.85); font-weight:800; }
  .pill .warn{ color: var(--amber); }
  .pill .bad{ color: var(--red); }
  .pill .good{ color: var(--green); }

  .gridArea{
    display:grid;
    grid-template-columns: 1.15fr .85fr;
    gap:12px;
  }

  .panel{
    background: linear-gradient(180deg, rgba(7,19,14,.90), rgba(6,17,12,.82));
    border:1px solid var(--border);
    box-shadow: var(--shadow);
    border-radius:16px;
    overflow:hidden;
  }

  .panelHeader{
    padding:10px 12px;
    border-bottom:1px solid var(--border2);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .panelHeader .h{
    font-weight:900;
    letter-spacing:1.6px;
    font-size:12px;
    color:rgba(53,255,155,.85);
  }
  .panelHeader .tiny{
    font-size:11px;
    color:rgba(53,255,155,.60);
  }

  /* Board */
  .boardWrap{
    padding:12px;
    display:grid;
    gap:10px;
    justify-items:center;
  }
/* Board sealed state */
.boardWrap.sealed {
  position: relative;
}

.boardWrap.sealed::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(
    180deg,
    rgba(0,0,0,0.15),
    rgba(0,0,0,0.55)
  );
  backdrop-filter: blur(1px);
  pointer-events: none;
  animation: sealFade .35s ease forwards;
}

@keyframes sealFade {
  from { opacity: 0; }
  to   { opacity: 1; }
}

  .status{
    min-height:18px;
    font-size:12px;
    color:rgba(53,255,155,.75);
    text-align:center;
    letter-spacing:1px;
  }

  .board{
    display:grid;
    gap:8px;
  }
  .row{
    display:grid;
    grid-template-columns: repeat(5, minmax(46px, 56px));
    gap:8px;
  }
  .cell{
    height:56px;
    display:grid;
    place-items:center;
    background: rgba(10,28,20,.85);
    border:1px solid rgba(53,255,155,.18);
    border-radius:14px;
    font-size:22px;
    font-weight:900;
    letter-spacing:2px;
    text-transform:uppercase;
    position:relative;
    overflow:hidden;
  }
  .cell::after{
    content:"";
    position:absolute;
    inset:0;
    background: linear-gradient(180deg, rgba(255,255,255,.05), transparent 55%);
    opacity:.45;
    pointer-events:none;
  }
  .cell.filled{ border-color: rgba(53,255,155,.32); }

  .cell.correct{
    border-color: rgba(53,255,155,.75);
    background: rgba(53,255,155,.14);
    color: var(--green);
    box-shadow: 0 0 18px rgba(53,255,155,.10);
  }
/* Victory pulse (on correct word) */
@keyframes winPulse {
  0% {
    box-shadow: 0 0 0 rgba(53,255,155,0);
  }
  50% {
    box-shadow: 0 0 22px rgba(53,255,155,0.45);
  }
  100% {
    box-shadow: 0 0 0 rgba(53,255,155,0);
  }
}

.cell.win {
  animation: winPulse .6s ease-out;
}
/* Continuous win modal glow */
@keyframes winGlowLoop {
  0% {
    box-shadow: 0 0 14px rgba(53,255,155,0.25);
  }
  50% {
    box-shadow: 0 0 32px rgba(53,255,155,0.55);
  }
  100% {
    box-shadow: 0 0 14px rgba(53,255,155,0.25);
  }
}

.brief.winGlowLoop {
  animation: winGlowLoop 2.2s ease-in-out infinite;
}

/* Fail modal flicker (entry) */
/* Fail modal entry shake + flash (smooth) */
@keyframes failFlicker {
  0% {
    transform: translateY(0);
    box-shadow: 0 0 0 rgba(255,95,95,0);
  }
  20% {
    transform: translateY(-2px);
    box-shadow: 0 0 18px rgba(255,95,95,0.45);
  }
  40% {
    transform: translateY(2px);
    box-shadow: 0 0 10px rgba(255,95,95,0.25);
  }
  60% {
    transform: translateY(-1px);
    box-shadow: 0 0 22px rgba(255,95,95,0.55);
  }
  100% {
    transform: translateY(0);
    box-shadow: 0 0 14px rgba(255,95,95,0.35);
  }
}

.brief.failFlicker {
  animation: failFlicker 0.32s ease-out;
}


/* Continuous fail glow */
@keyframes failGlowLoop {
  0% {
    box-shadow: 0 0 14px rgba(255,95,95,0.25);
  }
  50% {
    box-shadow: 0 0 32px rgba(255,95,95,0.55);
  }
  100% {
    box-shadow: 0 0 14px rgba(255,95,95,0.25);
  }
}

.brief.failGlowLoop {
  animation: failGlowLoop 2.2s ease-in-out infinite;
}


  .cell.present{
    border-color: rgba(255,204,102,.75);
    background: rgba(255,204,102,.12);
    color: var(--amber);
  }
  .cell.absent{
    border-color: rgba(255,95,95,.65);
    background: rgba(255,95,95,.10);
    color: var(--red);
  }

.flip {
  animation: flip .32s cubic-bezier(.4,.0,.2,1);
}

@keyframes flip{
  0%   { transform: rotateX(0deg); }
  45%  { transform: rotateX(80deg); }
  100% { transform: rotateX(0deg); }
}
  /* Keyboard */
  .kbd{
    width:100%;
    padding:10px 10px 12px;
    display:grid;
    gap:8px;
  }
  .kbd{
  width:100%;
  max-width:520px;   /* ðŸ‘ˆ keeps keyboard sane */
  margin:0 auto;
}
/* Keyboard locked state */
.kbd.locked {
  opacity: 0.35;
  pointer-events: none;
  filter: grayscale(40%);
}

.kbd.locked .key {
  cursor: default;
}
.krow{
  display:flex;
  gap:6px;
  justify-content:center;
  flex-wrap:nowrap; /* ðŸ”’ critical */
}
  .key{
  flex: 0 0 40px;     /* fixed key width */
  height:46px;
  padding:0;
  border-radius:14px;
  border:1px solid rgba(53,255,155,.22);
  background: rgba(6,17,12,.60);
  color: var(--green);
  font-weight:900;
  letter-spacing:1px;
  cursor:pointer;
  user-select:none;
  display:grid;
  place-items:center;
  font-size:12px;
}
  .key.spacer{
  flex: 0 0 20px;      /* space width */
  height: 46px;
  pointer-events: none;
  border: none;
  background: none;
}
  .key.wide{
  flex: 0 0 86px;  /* ENTER / DEL */
}
  .key:hover{ border-color: rgba(53,255,155,.45); }
  .key:active{ transform: translateY(1px); }

  .key.correct{ background: rgba(53,255,155,.14); border-color: rgba(53,255,155,.75); }
  .key.present{ background: rgba(255,204,102,.12); border-color: rgba(255,204,102,.75); color: var(--amber); }
  .key.absent{ background: rgba(255,95,95,.10); border-color: rgba(255,95,95,.65); color: var(--red); }

  /* Logs */
  .logs{
    padding:12px;
    height: 100%;
    display:grid;
    grid-template-rows: auto 1fr;
    gap:10px;
  }
  .logBox{
    border:1px solid rgba(53,255,155,.18);
    border-radius:14px;
    background: rgba(10,28,20,.55);
    padding:10px;
    height: 360px;
    overflow:hidden;
    position:relative;
  }
  .logLines{
    position:absolute;
    inset:10px;
    overflow:hidden;
    display:flex;
    flex-direction:column;
    gap:6px;
    font-size:11px;
    color: rgba(53,255,155,.75);
  }
  .logLine{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .tag{
    display:inline-block;
    padding:1px 6px;
    border:1px solid rgba(53,255,155,.22);
    border-radius:999px;
    margin-right:8px;
    color: rgba(53,255,155,.85);
  }
  .tag.warn{ border-color: rgba(255,204,102,.35); color: var(--amber); }
  .tag.bad{ border-color: rgba(255,95,95,.35); color: var(--red); }
  .tag.info{ border-color: rgba(98,230,255,.30); color: var(--cyan); }

  /* Intro overlay */
  .overlay{
    position:fixed;
    inset:0;
    background: rgba(0,0,0,.70);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    z-index:50;
  }
  .brief{
    width:min(720px, 100%);
    background: linear-gradient(180deg, rgba(7,19,14,.96), rgba(6,17,12,.92));
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow: 0 22px 80px rgba(0,0,0,.65);
    overflow:hidden;
  }
  .briefHead{
    padding:14px 14px 10px;
    border-bottom:1px solid var(--border2);
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
  }
  .briefHead .t{
    font-weight:900;
    letter-spacing:2px;
    font-size:14px;
  }
  .briefHead .lvl{
    font-size:11px;
    color: rgba(53,255,155,.70);
    letter-spacing:1px;
  }
  .briefBody{
    padding:14px;
    display:grid;
    gap:12px;
  }
  .briefBody p{
    margin:0;
    font-size:12px;
    line-height:1.55;
    color: rgba(53,255,155,.78);
  }
  .briefGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .card{
    border:1px solid rgba(53,255,155,.18);
    border-radius:14px;
    background: rgba(10,28,20,.55);
    padding:10px;
    font-size:11px;
    color: rgba(53,255,155,.76);
    line-height:1.5;
  }
  .card b{ color: rgba(53,255,155,.92); }
  .briefActions{
    display:flex;
    gap:10px;
    justify-content:flex-end;
    padding:14px;
    border-top:1px solid var(--border2);
  }

  /* Mobile layout: stack panels */
  @media (max-width: 820px){
    .gridArea{ grid-template-columns: 1fr; }
    .logBox{ height: 260px; }
    .meta{ grid-template-columns: 1fr; }
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="app" role="application" aria-label="Code Breaker Terminal">
    <div class="topbar">
      <div class="toprow">
        <div class="brand">
          <div class="title">CODE BREAKER // OPS</div>
          <div class="sub">Secure access required. Crack the 5-letter passcode in 6 attempts.</div>
        </div>
        <div class="controls">
          <button class="btn alt" id="copyBtn" type="button">COPY REPORT</button>
          <button class="btn" id="helpBtn" type="button">BRIEFING</button>
          <button class="btn danger" id="newBtn" type="button">NEW MISSION</button>
        </div>
      </div>

      <div class="meta">
        <div class="pill">
          <span><b>ATTEMPT</b></span>
          <span class="value" id="attemptPill">1 / 6</span>
        </div>
        <div class="pill">
          <span><b>SELF-DESTRUCT</b></span>
          <span class="value warn" id="timerPill">â€”</span>
        </div>
        <div class="pill">
          <span><b>MODE</b></span>
          <span class="value" id="modePill">STEALTH</span>
        </div>
        <div class="pill">
          <span><b>STATUS</b></span>
          <span class="value" id="statusPill">STANDBY</span>
        </div>
      </div>
    </div>

    <div class="gridArea">
      <!-- GAME PANEL -->
      <div class="panel">
        <div class="panelHeader">
          <div class="h">AUTHENTICATION CONSOLE</div>
          <div class="tiny" id="hintTiny">ENTER 5 LETTERS â€¢ PRESS ENTER</div>
        </div>

        <div class="boardWrap">
          <div class="status" id="status">>> STANDBY</div>
          <div class="board" id="board" aria-label="guess grid"></div>
        </div>

        <div class="kbd" id="keyboard" aria-label="on screen keyboard"></div>
      </div>

      <!-- LOGS PANEL -->
      <div class="panel">
        <div class="panelHeader">
          <div class="h">LIVE TELEMETRY</div>
          <div class="tiny">SIGNAL INTEGRITY: <span id="sigTiny">92%</span></div>
        </div>
        <div class="logs">
          <div class="logBox" aria-label="terminal logs">
            <div class="logLines" id="logLines"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- FAILURE OVERLAY -->
<div class="overlay" id="failOverlay" style="display:none;" role="dialog" aria-modal="true">
  <div class="brief">
    <div class="briefHead">
      <div>
        <div class="t">ACCESS DENIED</div>
        <div class="lvl">SECURITY PROTOCOL VIOLATION</div>
      </div>
    </div>

    <div class="briefBody">
      <p style="color:var(--red); font-weight:900;">
        SELF-DESTRUCT COMMENCED
      </p>

      <p>
        Authentication failed. The system has terminated your session.
      </p>

      <div class="card">
        <b>PASSCODE</b><br>
        <span id="failWord" style="font-size:18px; letter-spacing:3px;"></span>
      </div>
    </div>

    <div class="briefActions">
      <button class="btn danger" id="retryBtn" type="button">
        NEW MISSION
      </button>
    </div>
  </div>
</div>

<!-- SUCCESS OVERLAY -->
<div class="overlay" id="winOverlay" style="display:none;" role="dialog" aria-modal="true">
  <div class="brief">
    <div class="briefHead">
      <div>
        <div class="t" style="color:var(--green);">ACCESS GRANTED</div>
        <div class="lvl">AUTHENTICATION SUCCESSFUL</div>
      </div>
    </div>

    <div class="briefBody">
      <p style="color:var(--green); font-weight:900;">
        SYSTEM SECURED
      </p>

      <p>
        You have successfully infiltrated the target system.
      </p>

      <div class="card">
        <b>PASSCODE</b><br>
        <span id="winWord" style="font-size:18px; letter-spacing:3px;"></span>
      </div>

      <div class="card">
        <b>ATTEMPTS USED</b><br>
        <span id="winAttempts"></span>
      </div>
    </div>

    <div class="briefActions">
      <button class="btn alt" id="winRetryBtn" type="button">
        NEW MISSION
      </button>
    </div>
  </div>
</div>

<!-- BRIEFING OVERLAY -->

<div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="briefTitle">
  <div class="brief">
    <div class="briefHead">
      <div>
        <div class="t" id="briefTitle">MISSION BRIEFING</div>
        <div class="lvl">CLEARANCE: OMEGA â€¢ PROTOCOL: GHOSTKEY</div>
      </div>
      <button class="btn" id="closeOverlay" type="button">CLOSE</button>
    </div>

    <div class="briefBody">
      <p>
        Operative, your target system is protected by a <b>5-letter passcode</b>.
        You have <b>6 attempts</b> before the device initiates <b>self-destruct</b>.
        Each attempt returns a signal trace:
        <br>â€¢ <span style="color:var(--green);font-weight:900;">GREEN</span> = correct character and position
        <br>â€¢ <span style="color:var(--amber);font-weight:900;">AMBER</span> = character exists but is displaced
        <br>â€¢ <span style="color:var(--red);font-weight:900;">RED</span> = character not in passcode
      </p>

      <div class="briefGrid">
        <div class="card">
          <b>Objective</b><br>
          Infiltrate the system by discovering the passcode. Input may be any 5 letters.
        </div>
        <div class="card">
          <b>Threat</b><br>
          Self-destruct starts on your first keystroke. Keep calm and break the code.
        </div>
        <div class="card">
          <b>Extraction</b><br>
          On success, generate a mission report via <b>COPY REPORT</b>.
        </div>
        <div class="card">
          <b>Notes</b><br>
          Passcodes are selected from a secure bank each refresh / new mission.
        </div>
      </div>
    </div>

    <div class="briefActions">
      <button class="btn alt" id="startBtn" type="button">BEGIN OPERATION</button>
    </div>
  </div>
</div>

<script>
/* ==========================================================
   CODE BREAKER // OPS TERMINAL
   - Legit 5-letter "code word" bank (20)
   - Any 5-letter guess accepted
   - Sounds (WebAudio) generated on the fly
   - Self-destruct countdown
   - Scrolling fake terminal logs
   - Mission briefing intro
   - Shareable result output (copy)
   - Mobile-first UI
========================================================== */

/* ---------- CONFIG ---------- */
const ROWS = 6;
const COLS = 5;

// 20 legit 5-letter words (edit freely)
const WORD_BANK = [
  "TRACE","NEXUS","LASER","AGENT","SPIES",
  "VAULT","LOGIC","PROXY","CRYPT","STEEL",
  "SCOPE","RAVEN","GHOST","ALARM","BLADE",
  "RADIO","PRIME","SHARD","LOCKS","CROWN"
];

// Self-destruct seconds (starts on first input)
const SELF_DESTRUCT_SECONDS = 90;

// Log generation
const LOG_INTERVAL_MS = 850;
const MAX_LOG_LINES = 22;

/* ---------- DOM ---------- */
const boardEl = document.getElementById("board");
const keyboardEl = document.getElementById("keyboard");
const statusEl = document.getElementById("status");

const attemptPill = document.getElementById("attemptPill");
const timerPill = document.getElementById("timerPill");
const modePill = document.getElementById("modePill");
const statusPill = document.getElementById("statusPill");
const sigTiny = document.getElementById("sigTiny");

const overlay = document.getElementById("overlay");
const startBtn = document.getElementById("startBtn");
const closeOverlay = document.getElementById("closeOverlay");
const helpBtn = document.getElementById("helpBtn");
const newBtn = document.getElementById("newBtn");
const copyBtn = document.getElementById("copyBtn");
const logLinesEl = document.getElementById("logLines");
const failOverlay = document.getElementById("failOverlay");
const failWord = document.getElementById("failWord");
const retryBtn = document.getElementById("retryBtn");
const winOverlay = document.getElementById("winOverlay");
const winWord = document.getElementById("winWord");
const winAttempts = document.getElementById("winAttempts");
const winRetryBtn = document.getElementById("winRetryBtn");



/* ---------- STATE ---------- */
let SECRET = pickSecret();
let grid = Array.from({length:ROWS}, () => Array(COLS).fill(""));
let row = 0;
let col = 0;
let locked = false;

let keyState = new Map(); // letter -> absent/present/correct

let timerStarted = false;
let timeLeft = SELF_DESTRUCT_SECONDS;
let timerId = null;

let logsId = null;
let lastGuessResults = []; // store per-row results for share output (array of arrays)
let attemptOutcome = null; // "granted"|"denied"|null
let audioEnabled = true;

/* ---------- UTIL ---------- */
function pickSecret(){
  return WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];
}
function pad2(n){ return String(n).padStart(2,"0"); }
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function setStatus(text, pillText=null, pillClass=null){
  statusEl.textContent = text;
  statusPill.textContent = pillText ?? (locked ? (attemptOutcome === "granted" ? "GRANTED" : "DENIED") : "ACTIVE");
  statusPill.className = "value " + (pillClass ?? (attemptOutcome==="granted" ? "good" : attemptOutcome==="denied" ? "bad" : ""));
}

function updateAttemptPill(){
  attemptPill.textContent = `${Math.min(row+1, ROWS)} / ${ROWS}`;
}

function updateMode(){
  // tiny flavor: stealth -> breach as timer runs down
  const pct = timeLeft / SELF_DESTRUCT_SECONDS;
  modePill.textContent = pct > 0.66 ? "STEALTH" : pct > 0.33 ? "BREACH" : "PANIC";
  modePill.className = "value " + (pct > 0.66 ? "" : pct > 0.33 ? "warn" : "bad");
}

/* ---------- SOUND (WebAudio) ---------- */
let audioCtx = null;
let winPadOscs = [];
let winPadGain = null;

function ensureAudio(){
  if (!audioEnabled) return null;
  if (!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") audioCtx.resume();
  return audioCtx;
}

function beep({freq=880, dur=0.06, type="sine", gain=0.05} = {}){
  const ctx = ensureAudio();
  if (!ctx) return;

  const o = ctx.createOscillator();
  const g = ctx.createGain();

  o.type = type;
  o.frequency.value = freq;
  g.gain.value = 0;

  o.connect(g);
  g.connect(ctx.destination);

  const t = ctx.currentTime;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(gain, t + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

  o.start(t);
  o.stop(t + dur + 0.02);
}

function clickKey(){
  // short "tick"
  beep({freq: 1200 + Math.random()*200, dur: 0.03, type:"square", gain:0.03});
}
function beepEnter(){
  beep({freq: 780, dur: 0.05, type:"sine", gain:0.05});
  setTimeout(() => beep({freq: 980, dur: 0.06, type:"sine", gain:0.05}), 60);
}
function beepDenied(){
  beep({freq: 220, dur: 0.10, type:"sawtooth", gain:0.05});
  setTimeout(() => beep({freq: 180, dur: 0.14, type:"sawtooth", gain:0.05}), 90);
}
function beepGranted(){
  beep({freq: 660, dur: 0.06, type:"triangle", gain:0.05});
  setTimeout(() => beep({freq: 880, dur: 0.07, type:"triangle", gain:0.05}), 70);
  setTimeout(() => beep({freq: 1100, dur: 0.08, type:"triangle", gain:0.05}), 150);
}
function startWinPad(){
  const ctx = ensureAudio();
  if (!ctx) return;

  // Safety: stop existing pad
  stopWinPad();

  winPadGain = ctx.createGain();
  winPadGain.gain.value = 0;
  winPadGain.connect(ctx.destination);

  // Soft major chord (C major: Câ€“Eâ€“G)
  const freqs = [261.6, 329.6, 392.0];

  freqs.forEach(freq => {
    const osc = ctx.createOscillator();
    osc.type = "triangle"; // soft & warm
    osc.frequency.value = freq;

    osc.connect(winPadGain);
    osc.start();

    winPadOscs.push(osc);
  });

  // Gentle fade in
  winPadGain.gain.linearRampToValueAtTime(
    0.018,
    ctx.currentTime + 1.2
  );
// Auto-stop after a short calm moment
setTimeout(() => {
  stopWinPad();
}, 3200); // ~1.2s total presence

  // Subtle breathing (slow LFO)
  const lfo = ctx.createOscillator();
  const lfoGain = ctx.createGain();

  lfo.frequency.value = 0.15;      // very slow
  lfoGain.gain.value = 0.003;      // barely perceptible

  lfo.connect(lfoGain);
  lfoGain.connect(winPadGain.gain);
  lfo.start();

  // Store for cleanup
  winPadGain._lfo = lfo;
  winPadGain._lfoGain = lfoGain;
}

function stopWinPad(){
  if (!winPadGain || !audioCtx) return;

  const t = audioCtx.currentTime;

  winPadGain.gain.linearRampToValueAtTime(0.0001, t + 0.8);

  setTimeout(() => {
    winPadGain._lfo?.stop();
    winPadGain._lfo?.disconnect();
    winPadGain._lfoGain?.disconnect();

    winPadOscs.forEach(o => {
      o.stop();
      o.disconnect();
    });

    winPadOscs = [];
    winPadGain.disconnect();
    winPadGain = null;
  }, 900);
}

function beepAlarm(){
  beep({freq: 1400, dur: 0.06, type:"square", gain:0.03});
}
function beepAlarm(){
  beep({freq: 1400, dur: 0.06, type:"square", gain:0.03});
}

/* ---------- FAIL HUM (ambient) ---------- */
let failHumOsc = null;
let failHumGain = null;

function startFailHum(){
  const ctx = ensureAudio();
  if (!ctx || failHumOsc) return;

  failHumOsc = ctx.createOscillator();
  failHumGain = ctx.createGain();
// --- ominous tremble (slow instability) ---
const lfo = ctx.createOscillator();
const lfoGain = ctx.createGain();

lfo.type = "sine";
lfo.frequency.value = 0.6;     // slow pulse (â‰ˆ once every 1.6s)
lfoGain.gain.value = 0.004;    // VERY subtle volume wobble

lfo.connect(lfoGain);
lfoGain.connect(failHumGain.gain);
lfo.start();

// store refs for cleanup
failHumOsc._lfo = lfo;
failHumOsc._lfoGain = lfoGain;


  failHumOsc.type = "sine";
  failHumOsc.frequency.value = 110; // low ominous tone

  failHumGain.gain.value = 0;

  failHumOsc.connect(failHumGain);
  failHumGain.connect(ctx.destination);

  const t = ctx.currentTime;
  failHumGain.gain.linearRampToValueAtTime(0.015, t + 0.6); // gentle fade in

  failHumOsc.start();
}

function stopFailHum(){
  if (!failHumOsc) return;

  const ctx = audioCtx;
  const t = ctx.currentTime;

  failHumGain.gain.linearRampToValueAtTime(0.0001, t + 0.4); // fade out

  setTimeout(() => {
  // ðŸ”´ stop tremble (LFO)
  failHumOsc._lfo?.stop();
  failHumOsc._lfo?.disconnect();
  failHumOsc._lfoGain?.disconnect();

  // stop main hum
  failHumOsc.stop();
  failHumOsc.disconnect();
  failHumGain.disconnect();

  failHumOsc = null;
  failHumGain = null;
}, 450);

}


/* ---------- BOARD UI ---------- */
function buildBoard(){
  boardEl.innerHTML = "";
  for (let r=0; r<ROWS; r++){
    const rowEl = document.createElement("div");
    rowEl.className = "row";
    rowEl.dataset.row = r;

    for (let c=0; c<COLS; c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.setAttribute("aria-label", `Row ${r+1} col ${c+1}`);
      rowEl.appendChild(cell);
    }
    boardEl.appendChild(rowEl);
  }
}

function buildKeyboard(){
  keyboardEl.innerHTML = "";
  const rows = [
    "QWERTYUIOP".split(""),
    "ASDFGHJKL".split(""),
["SPACER","ENTER","Z","X","C","V","B","N","M","DEL","SPACER"]
  ];
  rows.forEach(keys => {
    const r = document.createElement("div");
    r.className = "krow";
    keys.forEach(k => {
  const el = document.createElement("div");

  // â¬› spacer keys (invisible, non-interactive)
  if (k === "SPACER") {
    el.className = "key spacer";
    r.appendChild(el);
    return;
  }

  // âŒ¨ï¸ normal keys
  el.className = "key" + ((k==="ENTER" || k==="DEL") ? " wide" : "");
  el.textContent = (k==="DEL") ? "âŒ«" : k;
  el.dataset.key = k;
  el.addEventListener("click", () => handleKey(k, true));
  r.appendChild(el);
});

    keyboardEl.appendChild(r);
  });
}

function render(){
  const rows = boardEl.querySelectorAll(".row");
  rows.forEach((rEl, r) => {
    const cells = [...rEl.children];
    cells.forEach((cell, c) => {
      const val = grid[r][c];
      cell.textContent = val;
      cell.classList.toggle("filled", !!val);
    });
  });

  // keyboard state
  document.querySelectorAll(".key").forEach(k => {
    const label = k.dataset.key;
    if (!label || label === "ENTER" || label === "DEL") return;
    k.classList.remove("absent","present","correct");
    const st = keyState.get(label);
    if (st) k.classList.add(st);
  });

  updateAttemptPill();
  updateMode();
}
function lockKeyboard(){
  keyboardEl.classList.add("locked");
}
function sealBoard(){
  document.querySelector(".boardWrap")?.classList.add("sealed");
}
function unlockUI(){
  keyboardEl.classList.remove("locked");
  document.querySelector(".boardWrap")?.classList.remove("sealed");
}




/* ---------- GAME LOGIC ---------- */
function bumpKey(letter, next){
  const order = {absent:0, present:1, correct:2};
  const cur = keyState.get(letter);
  if (!cur || order[next] > order[cur]) keyState.set(letter, next);
}

function scoreGuess(guess, answer){
  const res = Array(COLS).fill("absent");
  const A = answer.split("");
  const G = guess.split("");

  // correct
  for (let i=0;i<COLS;i++){
    if (G[i] === A[i]){
      res[i] = "correct";
      A[i] = null;
      G[i] = null;
    }
  }
  // present
  for (let i=0;i<COLS;i++){
    if (G[i] && A.includes(G[i])){
      res[i] = "present";
      A[A.indexOf(G[i])] = null;
    }
  }
  return res;
}

async function revealRow(result){
  const rowEl = boardEl.querySelector(`.row[data-row="${row}"]`);
  const cells = [...rowEl.children];

  for (let i = 0; i < COLS; i++){
    const cell = cells[i];

    await wait(90); // â¬… stagger timing

    cell.classList.remove("absent","present","correct");
    cell.classList.add("flip");

    await wait(120);

    cell.classList.add(result[i]);
    cell.classList.remove("flip");

    // micro feedback beep per state
    if (result[i] === "correct") beep({freq: 980, dur: 0.035, type:"sine", gain:0.04});
    if (result[i] === "present") beep({freq: 540, dur: 0.035, type:"sine", gain:0.03});
    if (result[i] === "absent")  beep({freq: 240, dur: 0.025, type:"square", gain:0.02});
  }
}

function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

function pushLetter(letter){
  if (locked) return;
  if (col >= COLS) return;

  if (!timerStarted) startTimer(); // first input starts countdown

  grid[row][col] = letter;
  col++;
  setStatus(">> INPUT RECEIVED", "ACTIVE");
  clickKey();
  render();
}

function popLetter(){
  if (locked) return;
  if (col <= 0) return;

  grid[row][col-1] = "";
  col--;
  clickKey();
  setStatus(">> EDIT BUFFER", "ACTIVE");
  render();
}

async function submit(){
  if (locked) return;

  if (col < COLS){
    setStatus(">> INCOMPLETE CODE", "ACTIVE", "warn");
    beep({freq: 320, dur: 0.06, type:"square", gain:0.03});
    return;
  }

  const guess = grid[row].join("");
  beepEnter();
  setStatus(">> VERIFYING...", "ACTIVE", "warn");

  const result = scoreGuess(guess, SECRET);
  lastGuessResults[row] = result;

  // update keyboard state
  for (let i=0;i<COLS;i++){
    bumpKey(guess[i], result[i]);
  }

  await revealRow(result);
  render();

  if (guess === SECRET){
    locked = true;
    attemptOutcome = "granted";
    setStatus(">> ACCESS GRANTED", "GRANTED", "good");
    beepGranted();
    stopTimer();
lockKeyboard();
sealBoard();
startWinPad();



// ðŸŽ‰ Victory pulse (NEW)
  const rowEl = boardEl.querySelector(`.row[data-row="${row}"]`);
  [...rowEl.children].forEach((cell, i) => {
    setTimeout(() => cell.classList.add("win"), i * 70);
  });

    addLog("info", "ACCESS_GRANTED", `PASSCODE ACCEPTED â€¢ TRIES_USED=${row+1}`);
setTimeout(showWinOverlay, 300);
    return;
  }

  row++;
  col = 0;

  if (row >= ROWS){
    locked = true;
    attemptOutcome = "denied";
    setStatus(`>> ACCESS DENIED // CODE: ${SECRET}`, "DENIED", "bad");
    beepDenied();
    stopTimer();
lockKeyboard();
sealBoard();
    addLog("bad", "LOCKDOWN", `AUTH FAILED â€¢ PASSCODE=${SECRET}`);
setTimeout(showFailOverlay, 500);
  } else {
    setStatus(">> AUTHENTICATION FAILED", "ACTIVE", "warn");
    addLog("warn", "AUTH_FAIL", `ATTEMPT=${row} â€¢ RESPONSE=NEGATIVE`);
  }
}

/* ---------- INPUT HANDLING ---------- */
function handleKey(k, fromClick=false){
  // Clicking keys should also enable audio (browser gesture requirement)
  if (fromClick) ensureAudio();

  if (k === "ENTER") return submit();
  if (k === "DEL") return popLetter();
  const letter = String(k).toUpperCase();
  if (/^[A-Z]$/.test(letter)) pushLetter(letter);
}

window.addEventListener("keydown", (e) => {
  if (overlay.style.display !== "none") return;

  if (e.key === "Enter") return handleKey("ENTER");
  if (e.key === "Backspace") return handleKey("DEL");
  if (/^[a-z]$/i.test(e.key)) return handleKey(e.key.toUpperCase());
});

/* ---------- TIMER (SELF-DESTRUCT) ---------- */
function startTimer(){
  timerStarted = true;
  timeLeft = SELF_DESTRUCT_SECONDS;
  updateTimerUI();
  addLog("warn", "ARMED", `SELF_DESTRUCT=T-${SELF_DESTRUCT_SECONDS}s`);
  timerId = setInterval(() => {
    if (locked) return;
    timeLeft--;
    updateTimerUI();

    // light alarm beeps under 15s
    if (timeLeft > 0 && timeLeft <= 15){
      beepAlarm();
      addLog("bad", "ALERT", `COUNTDOWN=T-${timeLeft}s`);
    }

    if (timeLeft <= 0){
  locked = true;
  attemptOutcome = "denied";

  setStatus(`>> SELF-DESTRUCT TRIGGERED`, "DENIED", "bad");
  beepDenied();
  stopTimer();

  lockKeyboard();
  sealBoard();

  addLog("bad", "TIMEOUT", `SELF-DESTRUCT EXECUTED â€¢ PASSCODE=${SECRET}`);

  // ðŸ”´ route into standard fail flow
  setTimeout(showFailOverlay, 500);
}

  }, 1000);
}

function stopTimer(){
  if (timerId) clearInterval(timerId);
  timerId = null;
  updateTimerUI();
}

function updateTimerUI(){
  if (!timerStarted || locked){
    timerPill.textContent = timerStarted ? "â€”" : "â€”";
    return;
  }
  const m = Math.floor(timeLeft / 60);
  const s = timeLeft % 60;
  timerPill.textContent = `${m}:${pad2(s)}`;
  timerPill.className = "value " + (timeLeft <= 15 ? "bad" : timeLeft <= 35 ? "warn" : "");
  sigTiny.textContent = `${clamp(70 + Math.floor((timeLeft/SELF_DESTRUCT_SECONDS)*25) - (row*3), 45, 99)}%`;
}

/* ---------- LOGS ---------- */
const LOG_TEMPLATES = [
  () => ["info","PING", `UPLINK_OK â€¢ RTT=${20+Math.floor(Math.random()*65)}ms`],
  () => ["info","SCAN", `PORT_SWEEP â€¢ OPEN=${Math.random() < 0.2 ? "443" : "NONE"}`],
  () => ["info","HASH", `SHA1_CHECK â€¢ MATCH=${Math.random() < 0.08 ? "TRUE" : "FALSE"}`],
  () => ["warn","TRACE", `ANOMALY_DETECTED â€¢ SIG=${(Math.random()*2).toFixed(2)}`],
  () => ["info","CACHE", `BUFFER_FLUSH â€¢ SECTOR=${100+Math.floor(Math.random()*900)}`],
  () => ["info","SYNC", `TIME_SYNC â€¢ DRIFT=${(Math.random()*4).toFixed(2)}ms`],
  () => ["warn","WAF", `RULE_TRIP â€¢ CODE=${1000+Math.floor(Math.random()*9000)}`],
  () => ["info","NODE", `ROUTE â€¢ HOPS=${2+Math.floor(Math.random()*8)}`],
  () => ["info","KEY", `KEYSPACE â€¢ ENTROPY=${(Math.random()*10+75).toFixed(1)}%`],
  () => ["bad","IDS", `INTRUSION_FLAG â€¢ LEVEL=${Math.random() < 0.7 ? "LOW" : "HIGH"}`]
];

function addLog(kind, tag, message){
  const t = new Date();
  const stamp = `${pad2(t.getHours())}:${pad2(t.getMinutes())}:${pad2(t.getSeconds())}`;

  const line = document.createElement("div");
  line.className = "logLine";
  const badge = document.createElement("span");
  badge.className = "tag " + (kind==="warn" ? "warn" : kind==="bad" ? "bad" : kind==="info" ? "info" : "");
  badge.textContent = tag;

  const text = document.createElement("span");
  text.textContent = `${stamp}  ${message}`;

  line.appendChild(badge);
  line.appendChild(text);

  logLinesEl.prepend(line);

  // trim
  while (logLinesEl.children.length > MAX_LOG_LINES){
    logLinesEl.removeChild(logLinesEl.lastChild);
  }
}

function startLogs(){
  if (logsId) clearInterval(logsId);
  logsId = setInterval(() => {
if (locked) return;
    const [k, tag, msg] = LOG_TEMPLATES[Math.floor(Math.random()*LOG_TEMPLATES.length)]();
    addLog(k, tag, msg);
  }, LOG_INTERVAL_MS);
}

function stopLogs(){
  if (logsId) clearInterval(logsId);
  logsId = null;
}

/* ---------- SHARE OUTPUT ---------- */
function emojiFor(state){
  if (state === "correct") return "ðŸŸ©";
  if (state === "present") return "ðŸŸ¨";
  return "â¬›";
}

function buildShareText(){
  const triesUsed = attemptOutcome === "granted" ? (row + 1) : "X";
  const header = `CODE BREAKER // ${attemptOutcome === "granted" ? `ACCESS GRANTED IN ${triesUsed}/${ROWS}` : `ACCESS DENIED ${triesUsed}/${ROWS}`}`;

  const lines = [];
  for (let r=0; r<ROWS; r++){
    const res = lastGuessResults[r];
    if (!res) continue;
    lines.push(res.map(emojiFor).join(""));
  }

  const footer = `#CodeBreakerOps`;
  return `${header}\n${lines.join("\n")}\n${footer}`;
}

async function copyReport(){
  const text = buildShareText();
  try{
    await navigator.clipboard.writeText(text);
    setStatus(">> REPORT COPIED TO CLIPBOARD", locked ? statusPill.textContent : "ACTIVE");
    beep({freq: 980, dur: 0.05, type:"triangle", gain:0.04});
    addLog("info", "EXPORT", "MISSION_REPORT=COPIED");
  }catch{
    // fallback: show prompt
    prompt("Copy your mission report:", text);
  }
}

/* ---------- NEW MISSION ---------- */
function resetGame(){
  SECRET = pickSecret();
  grid = Array.from({length:ROWS}, () => Array(COLS).fill(""));
  row = 0;
  col = 0;
  locked = false;
  keyState = new Map();
  lastGuessResults = [];
  attemptOutcome = null;

  timerStarted = false;
  timeLeft = SELF_DESTRUCT_SECONDS;
  stopTimer();

  buildBoard();
  render();

  logLinesEl.innerHTML = "";
  addLog("info","BOOT", "TERMINAL_READY â€¢ PROTOCOL=GHOSTKEY");
  addLog("info","LOAD", `WORD_BANK=20 â€¢ SESSION_ID=${Math.random().toString(16).slice(2,10).toUpperCase()}`);
  addLog("warn","NOTICE","SELF_DESTRUCT=ARM_ON_INPUT");
  setStatus(">> STANDBY", "STANDBY");
  timerPill.textContent = "â€”";
  modePill.textContent = "STEALTH";
  modePill.className = "value";
  sigTiny.textContent = "92%";
}

/* ---------- OVERLAY (BRIEFING) ---------- */
function showBriefing(){
  overlay.style.display = "flex";
}
function hideBriefing(){
  overlay.style.display = "none";
  // user gesture for audio permission
  ensureAudio();
  beep({freq: 520, dur: 0.06, type:"sine", gain:0.04});
}


/* ---------- OVERLAY (FAILURE) ---------- */
function showFailOverlay(){
  failOverlay.style.display = "flex";
startFailHum();


  const brief = failOverlay.querySelector(".brief");

  // Reset classes in case of replay
  brief.classList.remove("failFlicker", "failGlowLoop");

  // Entry flicker
  brief.classList.add("failFlicker");

  // After flicker, settle into steady glow
  setTimeout(() => {
    brief.classList.remove("failFlicker");
    brief.classList.add("failGlowLoop");
  }, 320);

  animateFailWord(SECRET);
}

function hideFailOverlay(){
  failOverlay.style.display = "none";
}

function animateFailWord(word){
  failWord.textContent = "";
  let i = 0;

  const interval = setInterval(() => {
    failWord.textContent += word[i];
    beep({ freq: 420, dur: 0.03, type: "square", gain: 0.02 });
    i++;

    if (i >= word.length) {
      clearInterval(interval);
    }
  }, 120);
}

/* ---------- OVERLAY (SUCCESS) ---------- */
function showWinOverlay(){
  winOverlay.style.display = "flex";

  const brief = winOverlay.querySelector(".brief");
  brief.classList.add("winGlowLoop");

  animateWinWord(SECRET);
  winAttempts.textContent = `${row + 1} / ${ROWS}`;
}

function hideWinOverlay(){
  winOverlay.style.display = "none";
}

function animateWinWord(word){
  winWord.textContent = "";
  let i = 0;

  const interval = setInterval(() => {
    winWord.textContent += word[i];
    beep({ freq: 620, dur: 0.03, type: "triangle", gain: 0.02 });
    i++;

    if (i >= word.length) {
      clearInterval(interval);
    }
  }, 120);
}


/* ---------- INIT ---------- */
buildKeyboard();
buildBoard();
startLogs();
resetGame();

// Show briefing on load
showBriefing();

startBtn.addEventListener("click", hideBriefing);
closeOverlay.addEventListener("click", hideBriefing);
helpBtn.addEventListener("click", showBriefing);

newBtn.addEventListener("click", () => {
  ensureAudio();
stopFailHum();   // ðŸ”´ ADD THIS
  stopWinPad();    // (safe, even if not playing)

  beep({freq: 360, dur: 0.06, type:"square", gain:0.04});
  resetGame();
  showBriefing();
});

copyBtn.addEventListener("click", () => {
  ensureAudio();
  copyReport();
});
retryBtn.addEventListener("click", () => {
  ensureAudio();

  const brief = failOverlay.querySelector(".brief");
  brief.classList.remove("failFlicker", "failGlowLoop");
  stopFailHum();   // ðŸ”´ ADD THIS

  hideFailOverlay();
  unlockUI();
  resetGame();
});

winRetryBtn.addEventListener("click", () => {
  ensureAudio();
stopWinPad();

  const brief = winOverlay.querySelector(".brief");
  brief.classList.remove("winGlowLoop");

  hideWinOverlay();
  unlockUI();
  resetGame();
});


// Click outside briefing to close
overlay.addEventListener("click", (e) => {
  if (e.target === overlay) hideBriefing();
});
</script>
</body>
</html>
